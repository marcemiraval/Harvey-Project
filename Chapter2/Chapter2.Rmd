---
title: "General-Public Reports About Hurricane Sandy"
author: "Marcela Suarez"
output:
  html_document: default
---


```{r load_packages, include=FALSE, echo=FALSE}

library(tidyverse)
library(sf)
library(leaflet)
library(htmltools)
library(maptools)
library(markdown)

```
# Data Preparation


This study relies on two main datasets. One corresponds to Spotters' reports extracted 
from the historic Storm Event Database from NOAA, which is available online. The second 
corresponds to geotagged Tweets collected and provided by the DOLLY project at the University
of Kentucky. Tweets contained in this dataset were sent from within the United States between
October 24 and October 31 of 2012 with explicit geographic information as latitude and
longitude coordinates.

Spatial information representing state boundaries was downloaded in shapefile format from the
United States Census Bureau website. Polygons representing state boundaries by 2017 are used 
in this study.

Based on this spatial dataset, a polygon representing the states affected by Hurricane Sandy 
was created. According to the SHELDUS database, the following states were affected by the
hurricane: Maryland, Delaware, New Jersey, New York, Connecticut, Massachusetts, Rhode Island,
North Carolina, Virginia, West Virginia, Ohio, Pennsylvania, New Hampshire and District of Columbia.

Based on this information, NWS reports and Tweets sent from these states were selected. We also filtered
only Tweets and reports sent within the two days with more impact reported (Oct/29/2012 and Oct/30/2012), 
which also were the days with reports from both data sources. After filtering, the NWS datasets contains
only 115 reports and the Twitter dataset contains 74807 tweets. 


# Data Analysis

```{r load_prepare_data, include=FALSE, echo=FALSE}

load(file= "Data/sandy_boundary_sf.RData")
load(file = "Data/sandySpotIn_sf.RData")
load(file = "Data/sandyTweetsIn_sf.RData")

#Prepare dataset to be used in function
sandySpotIn_sf <- sandySpotIn_sf %>%
  rename_at("EVENT_ID",~"id")  

```


The purpose of this analysis is to estimate the correspondence between the spatial distribution of Twitter reports and that of reports collected in a traditional fashion by the NWS. Grids of hexagons at a range of sizes are used to compare the overall variance in the density of reports across cells. That density is estimated for each data set as follows: 

***
$\frac{Number\ of\ Reports\ by\ Hexagon}{Total\ Number\ of\ Reports}$


*** 
$\frac{Number\ of\ Tweets\ by\ Hexagon}{Total\ Number\ of\ Tweets}$  


```{r list_hexagons_possibilities, include=FALSE, echo=FALSE}

sandy_boundary_sp <-  as(sandy_boundary_sf, "Spatial") # This doesn't go in data preparation because I guess I will use the sf version of the file later.
nHex <- c(h800 = 800, h1000 = 1000, h1200 = 1200,
          h1400 = 1400, h2000 = 2000)

```

```{r create_hexagonal_grids_sapply, include=FALSE, echo=FALSE}

creaHex <- function(hexNum) {
  sp_hex <- HexPoints2SpatialPolygons(spsample(sandy_boundary_sp, n = hexNum, type = "hexagonal"))
  sf_hex <- st_as_sf(sp_hex) %>%
    mutate(group = 1:nrow(.))
  }

hexagons <- lapply(nHex, creaHex)# Creates a Large list (5 elements, 5.5 Mb)

# Test lapply function
# ggplot() + geom_sf(data = hexagons$h800)
# ggplot() + geom_sf(data = hexagons$h2000) 
```

I get all counts of tweets based on hexagons definition. So I am adding reports information to hexagon information, not the opposite.

```{r join_compute_totals, include=FALSE, echo=FALSE}

# Compute the number of hurricane Sandy reports (NWS and Tweets) by hexagon
computeTotals <- function(hex_dfs, reports) {
  hexWithReports <- st_join(hex_dfs, reports) %>%
    group_by(group) %>%
    summarise(total = sum(!is.na(id))) %>%
    mutate(totRatio = total/sum(total))# Add column that normalize totals
}

TotalsSpotters <- lapply(hexagons, computeTotals, reports = sandySpotIn_sf)
TotalsTweets <- lapply(hexagons, computeTotals, reports = sandyTweetsIn_sf)
```

```{r maps, include=FALSE, echo=FALSE}
bins <- c(0, 1, 2, 3, 4, 5, 6, 7)
pal <- colorBin("YlOrRd", domain = Totals$h800$total, bins = bins)

SandyHexSpotMap <- leaflet(Totals$h800) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~pal(total),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Reports per hexagon: %i",total))) %>%
  addLegend(pal = pal, 
            values = ~total, 
            opacity = 0.7, 
            title = "Number of NWS reports",
            position = "bottomright")

SandyHexSpotMap



# Computing the number of hurricane Sandy related Tweets by hexagon
hexWithTweets <- st_join(sf_hex, sandyTweetsIn_sf) %>% 
  group_by(group) %>% 
  summarise(total = sum(!is.na(id))) %>% 
  mutate(totRatio = total/sum(total))

```

```{r export_shps, include=FALSE, echo=FALSE, eval = FALSE}
# Exporting shapefiles to test in QGIS
# Just turn eval to TRUE in case I need it
st_write(hexWithSpoReports, "hexWithSpot.shp", delete_layer = TRUE)
st_write(hexWithTweets, "hexWithTweets.shp", delete_layer = TRUE)
st_write(sandySpot_sf, "sandySpotReports.shp", layer_options = "GEOMETRY=AS_XY", delete_layer = TRUE)
```

```{r map_colo_reports, echo=FALSE, eval=FALSE}
coloSpot_sf <-  st_as_sf(coloSpot, coords = c("BEGIN_LON", "BEGIN_LAT"), crs = 4326)
coloTweets_sf <-  st_as_sf(coloradoT, coords = c("lon", "lat"), crs = 4326)


coloReportsMap <- leaflet(coloTweets_sf) %>% 
  addTiles()  %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite)%>% 
      addCircles(weight = 3, radius=40,
                 color="#ffa500", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(tweet)) %>%
      addCircles(data = coloSpot_sf, weight = 3, radius=40,
                 color="red", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(EVENT_NARRATIVE))%>% 
      setView(lng = -105.9, lat = 39.3, zoom = 8)

coloReportsMap

htmlwidgets::saveWidget(coloReportsMap, file = "coloReportsMap.html")
```

```{r map_Sandy_reports, echo=FALSE, eval=FALSE} 
# With EVAL false the map is not loading

SandyReportsMap <- leaflet(sandyTweetsIn_sf) %>% 
  addTiles()  %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite)%>% 
      addCircles(weight = 3, radius=40,
                 color="#ffa500", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(tweet)) %>%
      addCircles(data = sandySpot_sf, weight = 3, radius=40,
                 color="red", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(EVENT_NARRATIVE))%>% 
      setView(lng = -74.9, lat = 40.4, zoom = 6)

SandyReportsMap

htmlwidgets::saveWidget(SandyReportsMap, file = "SandyReportsMap2.html")
```

***

Aggregation to hexagons for NWS reports. 800 hexagons covering area of study.

```{r mapHexSandy_spotters, warning= FALSE, echo=FALSE}
bins <- c(0, 1, 2, 3, 4, 5, 6, 7)
pal <- colorBin("YlOrRd", domain = hexWithSpoReports$total, bins = bins)

SandyHexSpotMap <- leaflet(hexWithSpoReports) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~pal(total),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Reports per hexagon: %i",total))) %>%
  addLegend(pal = pal, 
            values = ~total, 
            opacity = 0.7, 
            title = "Number of NWS reports",
            position = "bottomright")

SandyHexSpotMap
# htmlwidgets::saveWidget(SandyHexSpotMap, file = "SandyHexSpotMap.html")
```
***

Normalizing aggregation to hexagons for NWS reports. 800 hexagons covering area of study.

$\frac{Number\ of\ Reports\ by\ Hexagon}{Total\ Number\ of\ Reports}$


```{r mapHexSandy_spotters_Norm, warning= FALSE, echo=FALSE}
bins <- c(0, 0.001, 0.009, 0.018, 0.027, 0.036, 0.55) # Breaks according to Natural Breaks (Jenks) classification.

pal <- colorBin("YlOrRd", domain = hexWithSpoReports$totRatio, bins = bins)

SandyHexSpotNorMap <- leaflet(hexWithSpoReports) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~pal(totRatio),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Reports per hexagon: %i",totRatio))) %>%
  addLegend(pal = pal, 
            values = ~totRatio, 
            opacity = 0.7, 
            title = "Ratio of NWS reports",
            position = "bottomright")

SandyHexSpotNorMap
htmlwidgets::saveWidget(SandyHexSpotNorMap, file = "SandyHexSpotNorMap.html")
```

*** 

Aggregation to hexagons for tweets. 800 hexagons covering area of study.

```{r mapHexSandy_Tweets, warning= FALSE, echo=FALSE}
binsTweets <- c(0, 1, 20, 100, 170, 322, 14500, 22000)
palTweets <- colorBin("YlOrRd", domain = hexWithTweets$total, bins = binsTweets)

SandyHexTweetMap <- leaflet(hexWithTweets) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~palTweets(total),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Tweets per hexagon: %i", total))) %>% ## This is no working but have no idea!
  addLegend(pal = palTweets, 
            values = ~total, 
            opacity = 0.7, 
            title = "Number of Tweets",
            position = "bottomright")

SandyHexTweetMap
# htmlwidgets::saveWidget(SandyHexTweetMap, file = "SandyHexTweetMap.html")
```

*** 

Normalizing aggregation to hexagons for tweets. 800 hexagons covering area of study.

$\frac{Number\ of\ Tweets\ by\ Hexagon}{Total\ Number\ of\ Tweets}$

```{r mapHexSandyNormTweets, warning= FALSE, echo=FALSE}

binsTweets <- c(0, 0.00096, 0.00327, 0.00682, 0.01647, 0.04823, 0.3000)  # Breaks according to Natural Breaks (Jenks) classification.

palTweets <- colorBin("YlOrRd", domain = hexWithTweets$totRatio, bins = binsTweets)

SandyHexTweetNorMap <- leaflet(hexWithTweets) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~palTweets(totRatio),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Tweets per hexagon: %i", total))) %>% ## This is no working but have no idea!
  addLegend(pal = palTweets, 
            values = ~totRatio, 
            opacity = 0.7, 
            title = "Ratio of Tweets",
            position = "bottomright")

SandyHexTweetNorMap
# htmlwidgets::saveWidget(SandyHexTweetNorMap, file = "SandyHexTweetNorMap.html")
```

```{r, warning= FALSE, echo=FALSE}
## NEXT.Choose the cell size that has the maximum variance.
```

