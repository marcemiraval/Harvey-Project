---
title: "General-Public Reports About Hurricane Sandy"
author: "Marcela Suarez"
output:
  html_document: default
---


```{r load_packages, include=FALSE, echo=FALSE}
library(tidyverse)
library(sf)
library(leaflet)
library(htmltools)
library(maptools)
library(data.table)
library(markdown)
```
# Data Preparation

This study relies on two main datasets. One corresponds to Spotters' reports extracted 
from the historic Storm Event Database from NOAA, which is available online. The second 
corresponds to geotagged Tweets collected and provided by the DOLLY project at the University
of Kentucky. Tweets contained in this dataset were sent from within the United States between
October 24 and October 31 of 2012 with explicit geographic information as latitude and
longitude coordinates.

Spatial information representing state boundaries was downloaded in shapefile format from the
United States Census Bureau website. Polygons representing state boundaries by 2017 are used 
in this study.

Based on this spatial dataset, a polygon representing the states affected by Hurricane Sandy 
was created. According to the SHELDUS database, the following states were affected by the
hurricane: Maryland, Delaware, New Jersey, New York, Connecticut, Massachusetts, Rhode Island,
North Carolina, Virginia, West Virginia, Ohio, Pennsylvania, New Hampshire and District of Columbia.

Based on this information, NWS reports and Tweets sent from these states were selected. We also filtered
only Tweets and reports sent within the two days with more impact reported (Oct/29/2012 and Oct/30/2012), 
which also were the days with reports from both data sources. After filtering, the NWS datasets contains
only 115 reports and the Twitter dataset contains 74807 tweets. 

# Data Analysis

## 1. Load Data

```{r load_data}
load(file= "Data/sandy_boundary_sf.RData")
load(file = "Data/sandySpotIn_sf.RData")
load(file = "Data/sandyTweetsIn_sf.RData")
```

## 2. Create Hexagonal Grid 

Created hexagons at a range of sizes and compare the overall variance in the values across cells. 
Choose the cell size that has the maximum variance.

```{r create_hexagonal_grid, include=FALSE, echo=FALSE}
sandy_boundary_sp <-  as(sandy_boundary_sf, "Spatial")
sp_hex <- HexPoints2SpatialPolygons(spsample(sandy_boundary_sp, n=800, type="hexagonal"))
sf_hex <- st_as_sf(sp_hex)
```

```{r create_hexagonal_grid_points, include=FALSE, echo=FALSE, eval=FALSE}
# To create hexagons based on points. -> To make sure every point has its own hexagon
spSandyTweets <- as(sandyTweetsIn_sf, 'Spatial')
sp_hexTweets <- HexPoints2SpatialPolygons(spsample(spSandyTweets, n = 800, type="hexagonal"))
sf_hexTweets <- st_as_sf(sp_hexTweets)
```

```{r project_data_planarCS, include=FALSE, echo=FALSE, eval= FALSE}
# In case I need to project to a planar system. Ask this option
# EPSG:102003 USA_Contiguous_Albers_Equal_Area_Conic
projSandy <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs"

sandySpot_sf <- sandySpot_sf %>% 
  st_transform(projSandy)

sf_hex <- sf_hex %>% 
  st_transform(projSandy)
```

I get all counts of tweets based on hexagons definition. So I am adding reports information to hexagon information, not the opposite.

```{r join_hex_and_Reports, include=FALSE, echo=FALSE}
sf_hex$group <- 1:nrow(sf_hex)

#### Join with Spotters ######
#spoReports <- st_join(sandySpot_sf, sf_hex)%>% # Not sure yet when I need this.
  #group_by(group)

# Compute the number of hurricane Sandy related NWS reports by hexagon
hexWithSpoReports <- st_join(sf_hex, sandySpotIn_sf)%>% 
  group_by(group) %>%
  summarise(total = sum(!is.na(EVENT_ID))) %>% 
  mutate(totRatio = total/sum(total))# Add column that normalize totals

# Computing the number of hurricane Sandy related Tweets by hexagon
hexWithTweets <- st_join(sf_hex, sandyTweetsIn_sf) %>% 
  group_by(group) %>% 
  summarise(total = sum(!is.na(id))) %>% 
  mutate(totRatio = total/sum(total))
```

```{r create_hists}
ggplot(hexWithTweets, aes(total)) + geom_histogram()
ggplot(hexWithTweets, aes(totRatio)) + geom_histogram()
ggplot(hexWithSpoReports, aes(total)) + geom_histogram()
ggplot(hexWithSpoReports, aes(totRatio)) + geom_histogram()

```


```{r export_shps, include=FALSE, echo=FALSE, eval = FALSE}
# Exporting shapefiles to test in QGIS
# Just turn eval to TRUE in case I need it
st_write(hexWithSpoReports, "Data/hexWithSpot.shp", delete_layer = TRUE)
st_write(hexWithTweets, "Data/hexWithTweets.shp", delete_layer = TRUE)
st_write(sandySpot_sf, "Data/sandySpotReports.shp", layer_options = "GEOMETRY=AS_XY", delete_layer = TRUE)
```

```{r map_colo_reports, echo=FALSE, eval=FALSE}
coloSpot_sf <-  st_as_sf(coloSpot, coords = c("BEGIN_LON", "BEGIN_LAT"), crs = 4326)
coloTweets_sf <-  st_as_sf(coloradoT, coords = c("lon", "lat"), crs = 4326)


coloReportsMap <- leaflet(coloTweets_sf) %>% 
  addTiles()  %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite)%>% 
      addCircles(weight = 3, radius=40,
                 color="#ffa500", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(tweet)) %>%
      addCircles(data = coloSpot_sf, weight = 3, radius=40,
                 color="red", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(EVENT_NARRATIVE))%>% 
      setView(lng = -105.9, lat = 39.3, zoom = 8)

coloReportsMap

htmlwidgets::saveWidget(coloReportsMap, file = "coloReportsMap.html")
```

```{r map_Sandy_reports, echo=FALSE, eval=FALSE} 
# With EVAL false the map is not loading

SandyReportsMap <- leaflet(sandyTweetsIn_sf) %>% 
  addTiles()  %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite)%>% 
      addCircles(weight = 3, radius=40,
                 color="#ffa500", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(tweet)) %>%
      addCircles(data = sandySpot_sf, weight = 3, radius=40,
                 color="red", stroke = TRUE, fillOpacity = 0.8,
                 popup = ~htmlEscape(EVENT_NARRATIVE))%>% 
      setView(lng = -74.9, lat = 40.4, zoom = 6)

SandyReportsMap

htmlwidgets::saveWidget(SandyReportsMap, file = "SandyReportsMap2.html")
```

***

Aggregation to hexagons for NWS reports. 800 hexagons covering area of study.

```{r mapHexSandy_spotters, warning= FALSE, echo=FALSE}
bins <- c(0, 1, 2, 3, 4, 5, 6, 7)
pal <- colorBin("YlOrRd", domain = hexWithSpoReports$total, bins = bins)

SandyHexSpotMap <- leaflet(hexWithSpoReports) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~pal(total),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Reports per hexagon: %i",total))) %>%
  addLegend(pal = pal, 
            values = ~total, 
            opacity = 0.7, 
            title = "Number of NWS reports",
            position = "bottomright")

SandyHexSpotMap
# htmlwidgets::saveWidget(SandyHexSpotMap, file = "SandyHexSpotMap.html")
```
***

Normalizing aggregation to hexagons for NWS reports. 800 hexagons covering area of study.

$\frac{Number\ of\ Reports\ by\ Hexagon}{Total\ Number\ of\ Reports}$


```{r mapHexSandy_spotters_Norm, warning= FALSE, echo=FALSE}
bins <- c(0, 0.001, 0.009, 0.018, 0.027, 0.036, 0.55) # Breaks according to Natural Breaks (Jenks) classification.

pal <- colorBin("YlOrRd", domain = hexWithSpoReports$totRatio, bins = bins)

SandyHexSpotNorMap <- leaflet(hexWithSpoReports) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~pal(totRatio),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Reports per hexagon: %i",totRatio))) %>%
  addLegend(pal = pal, 
            values = ~totRatio, 
            opacity = 0.7, 
            title = "Ratio of NWS reports",
            position = "bottomright")

SandyHexSpotNorMap
htmlwidgets::saveWidget(SandyHexSpotNorMap, file = "SandyHexSpotNorMap.html")
```

*** 

Aggregation to hexagons for tweets. 800 hexagons covering area of study.

```{r mapHexSandy_Tweets, warning= FALSE, echo=FALSE}
binsTweets <- c(0, 1, 20, 100, 170, 322, 14500, 22000)
palTweets <- colorBin("YlOrRd", domain = hexWithTweets$total, bins = binsTweets)

SandyHexTweetMap <- leaflet(hexWithTweets) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~palTweets(total),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Tweets per hexagon: %i", total))) %>% ## This is no working but have no idea!
  addLegend(pal = palTweets, 
            values = ~total, 
            opacity = 0.7, 
            title = "Number of Tweets",
            position = "bottomright")

SandyHexTweetMap
# htmlwidgets::saveWidget(SandyHexTweetMap, file = "SandyHexTweetMap.html")
```

*** 

Normalizing aggregation to hexagons for tweets. 800 hexagons covering area of study.

$\frac{Number\ of\ Tweets\ by\ Hexagon}{Total\ Number\ of\ Tweets}$

```{r mapHexSandyNormTweets, warning= FALSE, echo=FALSE}

binsTweets <- c(0, 0.00096, 0.00327, 0.00682, 0.01647, 0.04823, 0.3000)  # Breaks according to Natural Breaks (Jenks) classification.

palTweets <- colorBin("YlOrRd", domain = hexWithTweets$totRatio, bins = binsTweets)

SandyHexTweetNorMap <- leaflet(hexWithTweets) %>%
  setView(-74.9, 40.4, 6) %>%
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(fillColor = ~palTweets(totRatio),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "2",
              fillOpacity = 0.7,
              popup = ~htmlEscape(sprintf("Tweets per hexagon: %i", total))) %>% ## This is no working but have no idea!
  addLegend(pal = palTweets, 
            values = ~totRatio, 
            opacity = 0.7, 
            title = "Ratio of Tweets",
            position = "bottomright")

SandyHexTweetNorMap
# htmlwidgets::saveWidget(SandyHexTweetNorMap, file = "SandyHexTweetNorMap.html")
```

